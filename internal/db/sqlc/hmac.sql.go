// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: hmac.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const deactivateAllHMACKeys = `-- name: DeactivateAllHMACKeys :exec
UPDATE hmac_keys
SET is_active = false
WHERE is_active = true
`

func (q *Queries) DeactivateAllHMACKeys(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deactivateAllHMACKeys)
	return err
}

const getActiveHMACKey = `-- name: GetActiveHMACKey :one
SELECT id, key, created_at, expires_at, is_active
FROM hmac_keys
WHERE is_active = true
LIMIT 1
`

func (q *Queries) GetActiveHMACKey(ctx context.Context) (HmacKeys, error) {
	row := q.db.QueryRowContext(ctx, getActiveHMACKey)
	var i HmacKeys
	err := row.Scan(
		&i.ID,
		&i.Key,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.IsActive,
	)
	return i, err
}

const getSecretVersionWithHMAC = `-- name: GetSecretVersionWithHMAC :one
SELECT sv.id, sv.secret_id, sv.version, sv.encrypted_value, sv.nonce,
       sv.created_at, sv.created_by, sv.hmac_signature, sv.hmac_key_id,
       hk.key AS hmac_key
FROM secret_versions sv
JOIN hmac_keys hk ON sv.hmac_key_id = hk.id
WHERE sv.secret_id = $1 AND sv.version = $2
`

type GetSecretVersionWithHMACParams struct {
	SecretID uuid.UUID `json:"secret_id"`
	Version  int32     `json:"version"`
}

type GetSecretVersionWithHMACRow struct {
	ID             uuid.UUID     `json:"id"`
	SecretID       uuid.UUID     `json:"secret_id"`
	Version        int32         `json:"version"`
	EncryptedValue []byte        `json:"encrypted_value"`
	Nonce          []byte        `json:"nonce"`
	CreatedAt      sql.NullTime  `json:"created_at"`
	CreatedBy      uuid.NullUUID `json:"created_by"`
	HmacSignature  []byte        `json:"hmac_signature"`
	HmacKeyID      uuid.NullUUID `json:"hmac_key_id"`
	HmacKey        []byte        `json:"hmac_key"`
}

func (q *Queries) GetSecretVersionWithHMAC(ctx context.Context, arg GetSecretVersionWithHMACParams) (GetSecretVersionWithHMACRow, error) {
	row := q.db.QueryRowContext(ctx, getSecretVersionWithHMAC, arg.SecretID, arg.Version)
	var i GetSecretVersionWithHMACRow
	err := row.Scan(
		&i.ID,
		&i.SecretID,
		&i.Version,
		&i.EncryptedValue,
		&i.Nonce,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.HmacSignature,
		&i.HmacKeyID,
		&i.HmacKey,
	)
	return i, err
}

const insertHMACKey = `-- name: InsertHMACKey :one
INSERT INTO hmac_keys (key, expires_at, is_active)
VALUES ($1, $2, true)
RETURNING id
`

type InsertHMACKeyParams struct {
	Key       []byte       `json:"key"`
	ExpiresAt sql.NullTime `json:"expires_at"`
}

func (q *Queries) InsertHMACKey(ctx context.Context, arg InsertHMACKeyParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, insertHMACKey, arg.Key, arg.ExpiresAt)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
