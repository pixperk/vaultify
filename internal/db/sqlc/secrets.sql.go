// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: secrets.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createNewSecretVersion = `-- name: CreateNewSecretVersion :one
INSERT INTO secret_versions (secret_id, version, encrypted_value, nonce, created_by, expires_at)
SELECT 
  s.id, 
  COALESCE(MAX(sv.version), 0) + 1, 
  $2, $3, $4, $5
FROM secrets s
LEFT JOIN secret_versions sv ON s.id = sv.secret_id
WHERE s.path = $1
GROUP BY s.id
RETURNING id, secret_id, version, encrypted_value, nonce, created_at, created_by, expires_at
`

type CreateNewSecretVersionParams struct {
	Path           string        `json:"path"`
	EncryptedValue []byte        `json:"encrypted_value"`
	Nonce          []byte        `json:"nonce"`
	CreatedBy      uuid.NullUUID `json:"created_by"`
	ExpiresAt      sql.NullTime  `json:"expires_at"`
}

func (q *Queries) CreateNewSecretVersion(ctx context.Context, arg CreateNewSecretVersionParams) (SecretVersions, error) {
	row := q.db.QueryRowContext(ctx, createNewSecretVersion,
		arg.Path,
		arg.EncryptedValue,
		arg.Nonce,
		arg.CreatedBy,
		arg.ExpiresAt,
	)
	var i SecretVersions
	err := row.Scan(
		&i.ID,
		&i.SecretID,
		&i.Version,
		&i.EncryptedValue,
		&i.Nonce,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.ExpiresAt,
	)
	return i, err
}

const createSecretWithVersion = `-- name: CreateSecretWithVersion :one
WITH inserted_secret AS (
    INSERT INTO secrets (user_id, path)
    VALUES ($1, $2)
    RETURNING id
)
INSERT INTO secret_versions (secret_id, version, encrypted_value, nonce, created_by, expires_at)
VALUES (
    (SELECT id FROM inserted_secret), 1, $3, $4, $1, $5
)
RETURNING id, secret_id, version, encrypted_value, nonce, created_at, created_by, expires_at
`

type CreateSecretWithVersionParams struct {
	CreatedBy      uuid.NullUUID `json:"created_by"`
	Path           string        `json:"path"`
	EncryptedValue []byte        `json:"encrypted_value"`
	Nonce          []byte        `json:"nonce"`
	ExpiresAt      sql.NullTime  `json:"expires_at"`
}

func (q *Queries) CreateSecretWithVersion(ctx context.Context, arg CreateSecretWithVersionParams) (SecretVersions, error) {
	row := q.db.QueryRowContext(ctx, createSecretWithVersion,
		arg.CreatedBy,
		arg.Path,
		arg.EncryptedValue,
		arg.Nonce,
		arg.ExpiresAt,
	)
	var i SecretVersions
	err := row.Scan(
		&i.ID,
		&i.SecretID,
		&i.Version,
		&i.EncryptedValue,
		&i.Nonce,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.ExpiresAt,
	)
	return i, err
}

const deleteExpiredSecretVersions = `-- name: DeleteExpiredSecretVersions :exec
DELETE FROM secret_versions
WHERE expires_at IS NOT NULL AND expires_at < now()
`

func (q *Queries) DeleteExpiredSecretVersions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredSecretVersions)
	return err
}

const deleteSecretAndVersionsByPath = `-- name: DeleteSecretAndVersionsByPath :exec
WITH deleted AS (
    DELETE FROM secrets
    WHERE path = $1
    RETURNING id
)
DELETE FROM secret_versions
WHERE secret_id IN (SELECT id FROM deleted)
`

func (q *Queries) DeleteSecretAndVersionsByPath(ctx context.Context, path string) error {
	_, err := q.db.ExecContext(ctx, deleteSecretAndVersionsByPath, path)
	return err
}

const getAllSecretVersionsByPath = `-- name: GetAllSecretVersionsByPath :many
SELECT sv.id, sv.secret_id, sv.version, sv.encrypted_value, sv.nonce, sv.created_at, sv.created_by, sv.expires_at
FROM secrets s
JOIN secret_versions sv ON s.id = sv.secret_id
WHERE s.path = $1
ORDER BY sv.version DESC
`

func (q *Queries) GetAllSecretVersionsByPath(ctx context.Context, path string) ([]SecretVersions, error) {
	rows, err := q.db.QueryContext(ctx, getAllSecretVersionsByPath, path)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SecretVersions{}
	for rows.Next() {
		var i SecretVersions
		if err := rows.Scan(
			&i.ID,
			&i.SecretID,
			&i.Version,
			&i.EncryptedValue,
			&i.Nonce,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestSecretByPath = `-- name: GetLatestSecretByPath :one
SELECT sv.id, sv.secret_id, sv.version, sv.encrypted_value, sv.nonce, sv.created_at, sv.created_by, sv.expires_at, s.id AS secret_id, s.path
FROM secrets s
JOIN secret_versions sv ON s.id = sv.secret_id
WHERE s.path = $1
  AND (sv.expires_at IS NULL OR sv.expires_at > now())
ORDER BY sv.version DESC
LIMIT 1
`

type GetLatestSecretByPathRow struct {
	ID             uuid.UUID     `json:"id"`
	SecretID       uuid.UUID     `json:"secret_id"`
	Version        int32         `json:"version"`
	EncryptedValue []byte        `json:"encrypted_value"`
	Nonce          []byte        `json:"nonce"`
	CreatedAt      sql.NullTime  `json:"created_at"`
	CreatedBy      uuid.NullUUID `json:"created_by"`
	ExpiresAt      sql.NullTime  `json:"expires_at"`
	SecretID_2     uuid.UUID     `json:"secret_id_2"`
	Path           string        `json:"path"`
}

func (q *Queries) GetLatestSecretByPath(ctx context.Context, path string) (GetLatestSecretByPathRow, error) {
	row := q.db.QueryRowContext(ctx, getLatestSecretByPath, path)
	var i GetLatestSecretByPathRow
	err := row.Scan(
		&i.ID,
		&i.SecretID,
		&i.Version,
		&i.EncryptedValue,
		&i.Nonce,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.ExpiresAt,
		&i.SecretID_2,
		&i.Path,
	)
	return i, err
}

const getLatestSecretsForUser = `-- name: GetLatestSecretsForUser :many
SELECT DISTINCT ON (s.id) s.id AS secret_id, s.path, sv.version, sv.encrypted_value, sv.nonce, sv.created_at, sv.expires_at
FROM secrets s
JOIN secret_versions sv ON s.id = sv.secret_id
WHERE s.user_id = $1
  AND (sv.expires_at IS NULL OR sv.expires_at > now())
ORDER BY s.id, sv.version DESC
`

type GetLatestSecretsForUserRow struct {
	SecretID       uuid.UUID    `json:"secret_id"`
	Path           string       `json:"path"`
	Version        int32        `json:"version"`
	EncryptedValue []byte       `json:"encrypted_value"`
	Nonce          []byte       `json:"nonce"`
	CreatedAt      sql.NullTime `json:"created_at"`
	ExpiresAt      sql.NullTime `json:"expires_at"`
}

func (q *Queries) GetLatestSecretsForUser(ctx context.Context, userID uuid.UUID) ([]GetLatestSecretsForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getLatestSecretsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLatestSecretsForUserRow{}
	for rows.Next() {
		var i GetLatestSecretsForUserRow
		if err := rows.Scan(
			&i.SecretID,
			&i.Path,
			&i.Version,
			&i.EncryptedValue,
			&i.Nonce,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestVersionNumberByPath = `-- name: GetLatestVersionNumberByPath :one
SELECT COALESCE(MAX(sv.version), 0) AS latest_version
FROM secrets s
LEFT JOIN secret_versions sv ON s.id = sv.secret_id
WHERE s.path = $1
`

func (q *Queries) GetLatestVersionNumberByPath(ctx context.Context, path string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getLatestVersionNumberByPath, path)
	var latest_version interface{}
	err := row.Scan(&latest_version)
	return latest_version, err
}

const getSecretVersionByPathAndVersion = `-- name: GetSecretVersionByPathAndVersion :one
SELECT sv.id, sv.secret_id, sv.version, sv.encrypted_value, sv.nonce, sv.created_at, sv.created_by, sv.expires_at, s.id AS secret_id, s.path
FROM secrets s
JOIN secret_versions sv ON s.id = sv.secret_id
WHERE s.path = $1 AND sv.version = $2
`

type GetSecretVersionByPathAndVersionParams struct {
	Path    string `json:"path"`
	Version int32  `json:"version"`
}

type GetSecretVersionByPathAndVersionRow struct {
	ID             uuid.UUID     `json:"id"`
	SecretID       uuid.UUID     `json:"secret_id"`
	Version        int32         `json:"version"`
	EncryptedValue []byte        `json:"encrypted_value"`
	Nonce          []byte        `json:"nonce"`
	CreatedAt      sql.NullTime  `json:"created_at"`
	CreatedBy      uuid.NullUUID `json:"created_by"`
	ExpiresAt      sql.NullTime  `json:"expires_at"`
	SecretID_2     uuid.UUID     `json:"secret_id_2"`
	Path           string        `json:"path"`
}

func (q *Queries) GetSecretVersionByPathAndVersion(ctx context.Context, arg GetSecretVersionByPathAndVersionParams) (GetSecretVersionByPathAndVersionRow, error) {
	row := q.db.QueryRowContext(ctx, getSecretVersionByPathAndVersion, arg.Path, arg.Version)
	var i GetSecretVersionByPathAndVersionRow
	err := row.Scan(
		&i.ID,
		&i.SecretID,
		&i.Version,
		&i.EncryptedValue,
		&i.Nonce,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.ExpiresAt,
		&i.SecretID_2,
		&i.Path,
	)
	return i, err
}

const getSecretsWithVersionCount = `-- name: GetSecretsWithVersionCount :many
SELECT s.id, s.path, COUNT(sv.id) AS version_count
FROM secrets s
LEFT JOIN secret_versions sv ON s.id = sv.secret_id
GROUP BY s.id, s.path
ORDER BY version_count DESC
`

type GetSecretsWithVersionCountRow struct {
	ID           uuid.UUID `json:"id"`
	Path         string    `json:"path"`
	VersionCount int64     `json:"version_count"`
}

func (q *Queries) GetSecretsWithVersionCount(ctx context.Context) ([]GetSecretsWithVersionCountRow, error) {
	rows, err := q.db.QueryContext(ctx, getSecretsWithVersionCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSecretsWithVersionCountRow{}
	for rows.Next() {
		var i GetSecretsWithVersionCountRow
		if err := rows.Scan(&i.ID, &i.Path, &i.VersionCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
