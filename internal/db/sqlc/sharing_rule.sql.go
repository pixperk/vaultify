// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: sharing_rule.sql

package db

import (
	"context"
	"database/sql"
)

const checkIfShared = `-- name: CheckIfShared :one
SELECT EXISTS (
    SELECT 1
    FROM sharing_rules
    WHERE path = $1 AND target_email = $2 
    AND (shared_until IS NULL OR shared_until > NOW())
)
`

type CheckIfSharedParams struct {
	Path        string `json:"path"`
	TargetEmail string `json:"target_email"`
}

func (q *Queries) CheckIfShared(ctx context.Context, arg CheckIfSharedParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkIfShared, arg.Path, arg.TargetEmail)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const deleteExpiredSharingRules = `-- name: DeleteExpiredSharingRules :exec
DELETE FROM sharing_rules
WHERE shared_until IS NOT NULL AND shared_until < NOW()
`

func (q *Queries) DeleteExpiredSharingRules(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredSharingRules)
	return err
}

const getPermissions = `-- name: GetPermissions :one
SELECT permission
FROM sharing_rules
WHERE path = $1 AND target_email = $2 
AND (shared_until IS NULL OR shared_until > NOW())
`

type GetPermissionsParams struct {
	Path        string `json:"path"`
	TargetEmail string `json:"target_email"`
}

func (q *Queries) GetPermissions(ctx context.Context, arg GetPermissionsParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getPermissions, arg.Path, arg.TargetEmail)
	var permission string
	err := row.Scan(&permission)
	return permission, err
}

const getSecretsSharedWithMe = `-- name: GetSecretsSharedWithMe :many
SELECT path, permission, owner_email
FROM sharing_rules
WHERE target_email = $1 
AND (shared_until IS NULL OR shared_until > NOW())
`

type GetSecretsSharedWithMeRow struct {
	Path       string `json:"path"`
	Permission string `json:"permission"`
	OwnerEmail string `json:"owner_email"`
}

func (q *Queries) GetSecretsSharedWithMe(ctx context.Context, targetEmail string) ([]GetSecretsSharedWithMeRow, error) {
	rows, err := q.db.QueryContext(ctx, getSecretsSharedWithMe, targetEmail)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSecretsSharedWithMeRow{}
	for rows.Next() {
		var i GetSecretsSharedWithMeRow
		if err := rows.Scan(&i.Path, &i.Permission, &i.OwnerEmail); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSharedWith = `-- name: GetSharedWith :many
SELECT owner_email, target_email 
FROM sharing_rules
WHERE path = $1 AND (shared_until IS NULL OR shared_until > NOW())
AND target_email != $2
`

type GetSharedWithParams struct {
	Path        string `json:"path"`
	TargetEmail string `json:"target_email"`
}

type GetSharedWithRow struct {
	OwnerEmail  string `json:"owner_email"`
	TargetEmail string `json:"target_email"`
}

func (q *Queries) GetSharedWith(ctx context.Context, arg GetSharedWithParams) ([]GetSharedWithRow, error) {
	rows, err := q.db.QueryContext(ctx, getSharedWith, arg.Path, arg.TargetEmail)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSharedWithRow{}
	for rows.Next() {
		var i GetSharedWithRow
		if err := rows.Scan(&i.OwnerEmail, &i.TargetEmail); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const shareSecret = `-- name: ShareSecret :one
INSERT INTO sharing_rules (owner_email, target_email, path, permission, shared_until)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, owner_email, target_email, path, permission, created_at, shared_until
`

type ShareSecretParams struct {
	OwnerEmail  string       `json:"owner_email"`
	TargetEmail string       `json:"target_email"`
	Path        string       `json:"path"`
	Permission  string       `json:"permission"`
	SharedUntil sql.NullTime `json:"shared_until"`
}

func (q *Queries) ShareSecret(ctx context.Context, arg ShareSecretParams) (SharingRules, error) {
	row := q.db.QueryRowContext(ctx, shareSecret,
		arg.OwnerEmail,
		arg.TargetEmail,
		arg.Path,
		arg.Permission,
		arg.SharedUntil,
	)
	var i SharingRules
	err := row.Scan(
		&i.ID,
		&i.OwnerEmail,
		&i.TargetEmail,
		&i.Path,
		&i.Permission,
		&i.CreatedAt,
		&i.SharedUntil,
	)
	return i, err
}
