// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: audit_log.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO audit_logs (
  user_id,
  user_email,
  action,
  resource_version,
  resource_path,
  success,
  reason
)
VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, user_id, user_email, action, resource_version, resource_path, success, reason, created_at
`

type CreateAuditLogParams struct {
	UserID          uuid.UUID      `json:"user_id"`
	UserEmail       string         `json:"user_email"`
	Action          string         `json:"action"`
	ResourceVersion int32          `json:"resource_version"`
	ResourcePath    string         `json:"resource_path"`
	Success         bool           `json:"success"`
	Reason          sql.NullString `json:"reason"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLogs, error) {
	row := q.db.QueryRowContext(ctx, createAuditLog,
		arg.UserID,
		arg.UserEmail,
		arg.Action,
		arg.ResourceVersion,
		arg.ResourcePath,
		arg.Success,
		arg.Reason,
	)
	var i AuditLogs
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserEmail,
		&i.Action,
		&i.ResourceVersion,
		&i.ResourcePath,
		&i.Success,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const filterAuditLogs = `-- name: FilterAuditLogs :many
SELECT id, user_id, user_email, action, resource_version, resource_path, success, reason, created_at FROM audit_logs
WHERE 
  ($1::TEXT IS NULL OR user_email = $1)
  AND ($2::TEXT IS NULL OR resource_version = $2)
  AND ($3::TEXT IS NULL OR action = $3)
  AND ($4::TIMESTAMPTZ IS NULL OR created_at >= $4)
  AND ($5::TIMESTAMPTZ IS NULL OR created_at <= $5)
ORDER BY created_at DESC
LIMIT $6 OFFSET $7
`

type FilterAuditLogsParams struct {
	Column1 string    `json:"column_1"`
	Column2 string    `json:"column_2"`
	Column3 string    `json:"column_3"`
	Column4 time.Time `json:"column_4"`
	Column5 time.Time `json:"column_5"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

func (q *Queries) FilterAuditLogs(ctx context.Context, arg FilterAuditLogsParams) ([]AuditLogs, error) {
	rows, err := q.db.QueryContext(ctx, filterAuditLogs,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLogs{}
	for rows.Next() {
		var i AuditLogs
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UserEmail,
			&i.Action,
			&i.ResourceVersion,
			&i.ResourcePath,
			&i.Success,
			&i.Reason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
