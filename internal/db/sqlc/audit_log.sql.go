// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: audit_log.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO audit_logs (
  user_id,
  user_email,
  action,
  resource_version,
  resource_path,
  success,
  reason
)
VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, user_id, user_email, action, resource_version, resource_path, success, reason, created_at
`

type CreateAuditLogParams struct {
	UserID          uuid.UUID      `json:"user_id"`
	UserEmail       string         `json:"user_email"`
	Action          string         `json:"action"`
	ResourceVersion int32          `json:"resource_version"`
	ResourcePath    string         `json:"resource_path"`
	Success         bool           `json:"success"`
	Reason          sql.NullString `json:"reason"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLogs, error) {
	row := q.db.QueryRowContext(ctx, createAuditLog,
		arg.UserID,
		arg.UserEmail,
		arg.Action,
		arg.ResourceVersion,
		arg.ResourcePath,
		arg.Success,
		arg.Reason,
	)
	var i AuditLogs
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserEmail,
		&i.Action,
		&i.ResourceVersion,
		&i.ResourcePath,
		&i.Success,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const filterAuditLogs = `-- name: FilterAuditLogs :many
SELECT id, user_id, user_email, action, resource_version, resource_path, success, reason, created_at FROM audit_logs
WHERE
  (user_email = $1 OR $1 = '')
  AND (resource_version = $2 OR $2 = 0)
  AND (action = $3 OR $3 = '')
  AND (created_at >= $4 OR $4 IS NULL)
  AND (created_at <= $5 OR $5 IS NULL)
  AND (resource_path = $6 OR $6 = '')
  AND (success = $7 OR $7 IS NULL)
ORDER BY created_at DESC
LIMIT $8 OFFSET $9
`

type FilterAuditLogsParams struct {
	UserEmail       string       `json:"user_email"`
	ResourceVersion int32        `json:"resource_version"`
	Action          string       `json:"action"`
	CreatedAt       sql.NullTime `json:"created_at"`
	CreatedAt_2     sql.NullTime `json:"created_at_2"`
	ResourcePath    string       `json:"resource_path"`
	Success         bool         `json:"success"`
	Limit           int32        `json:"limit"`
	Offset          int32        `json:"offset"`
}

func (q *Queries) FilterAuditLogs(ctx context.Context, arg FilterAuditLogsParams) ([]AuditLogs, error) {
	rows, err := q.db.QueryContext(ctx, filterAuditLogs,
		arg.UserEmail,
		arg.ResourceVersion,
		arg.Action,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.ResourcePath,
		arg.Success,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLogs{}
	for rows.Next() {
		var i AuditLogs
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UserEmail,
			&i.Action,
			&i.ResourceVersion,
			&i.ResourcePath,
			&i.Success,
			&i.Reason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
